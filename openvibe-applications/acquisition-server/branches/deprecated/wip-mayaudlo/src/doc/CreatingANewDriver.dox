/**
 * \page Doc_CreatingANewDriver Creating a new driver for the acquisition server
 *
 * \section Doc_CreatingANewDriver_Introduction Introduction
 *
 * This page is targeted at driver developers. It provides information regarding the creation of a new
 * acquisition driver for the §OpenViBE§ acquisition server. A driver is a
 * single object that interacts with a hardware acquisition peripheral and formats
 * acquired data (measures and other information) so that they are understandable by the acquisition server.
 * Once the acquisition server starts receiving data from a driver, it is able to
 * send it to any number of connected clients.
 *
 * Connection details between the hardware and the driver aren't of concern
 * to the acquisition server. Some hardware manufacturers choose to provide an API
 * so that the driver has direct access to the peripheral through a physical connection
 * (e.g. USB, serial port or some other port). Others provide a proprietary acquisition
 * server, which allows connections through TCP/IP to stream measures in
 * real time. Whatever a given hardware manufacturer provides, the §OpenViBE§ driver
 * is in charge of collecting a set of information / measures and formatting
 * them according to the §OpenViBE§ specification.
 *
 * \section Doc_CreatingANewDriver_HowIsTheDriverUsed How is the driver used ?
 *
 * First, the driver has to identify itself by providing a name to the acquisition server.
 * This name will appear in the acquisition server GUI, and serve to easily identify the hardware
 * the user is working with. This is why one should give the driver as precise a name as possible,
 * including e.g. the name of the hardware manufacturer and the hardware model handled by the driver.
 *
 * The driver essentially deals with two kinds of data :
 *  - the header
 *  - the buffer
 *
 * The header consists of fixed data (that does not change with). It contains
 * several identifiers about the experiment being conducted, information about
 * the channels being acquired and so on. See OpenViBEAcquisitionServer::IHeader
 * for more details about this header.
 *
 * The buffer contains data that changes with time. It consists of a number of
 * samples for each channel over a given time period. This period depends on
 * the number of samples to be sent per channel, a value given to the driver
 * during the initialization phase.
 *
 * To deal with these data, the driver is used by the acquisition server
 * at different execution stages, the three most important of which are :
 *  - configuration
 *  - intialization / uninitialization
 *  - acquisition
 *
 * The configuration stage can be used by the driver to request 
 * header information that can't be retrieved from the hardware. Depending
 * on the hardware considered, header information may be found
 * in streamed data, resulting in a non-configurable driver (which makes
 * it easier for the acquisition server user). For example, a driver based on a
 * physical connection with the hardware may not provide the subject age or sex. Such a driver
 * will need a configuration phase before it can be used.
 *
 * In the initialization stage, the driver requests readiness status from the
 * hardware. Once the driver is initialized (meaning
 * OpenViBEAcquisitionServer::IDriver::initialize has returned), it
 * should have a complete header ready to be sent to the acquisition server.
 *
 * The acquisition stage starts when OpenViBEAcquisitionServer::IDriver::start
 * is called. From this point on, the driver is regularly requested to provide
 * new data from within the OpenViBEAcquisitionServer::IDriver::loop function.
 *
 * A schematic representation of the automaton for a driver is shown below :
 *
 * \image html driver_automate.png "The driver automaton"
 *
 * Now that you know what a driver is, we shall go on coding it :)
 *
 * \section Doc_CreatingANewDriver_CodingTheDriver Coding the driver
 *
 * Coding the driver consists in implementing an
 * OpenViBEAcquisitionServer::IDriver object. To that end, here is 
 * a driver skeleton for you to use...
 *
 * The header would look like this :
 *
 * \code
 * #include <IDriver.h>
 *
 * class CYourDriver : virtual public OpenViBEAcquisitionServer::IDriver
 * {
 * public:
 *   CYourDriver(void);
 *   virtual ~CYourDriver(void);
 *   virtual void release(void) { delete this; }
 *   virtual const char* getName(void) { return "put your driver name here"; }
 *
 *   virtual OpenViBEAcquisitionServer::boolean isConfigurable(void);
 *   virtual OpenViBEAcquisitionServer::boolean configure(void);
 *
 *   virtual OpenViBEAcquisitionServer::boolean initialize(
 *     const OpenViBEAcquisitionServer::uint32 ui32SampleCountPerChannel,
 *     OpenViBEAcquisitionServer::IDriverCallback& rCallback);
 *   virtual OpenViBEAcquisitionServer::boolean uninitialize(void);
 *   virtual const OpenViBEAcquisitionServer::IHeader* getHeader(void);
 *
 *   virtual OpenViBEAcquisitionServer::boolean start(void);
 *   virtual OpenViBEAcquisitionServer::boolean stop(void);
 *   virtual OpenViBEAcquisitionServer::boolean loop(void);
 *
 * protected:
 *   OpenViBEAcquisitionServer::IHeader* m_pHeader;
 *   OpenViBEAcquisitionServer::boolean m_bInitialized;
 *   OpenViBEAcquisitionServer::boolean m_bStarted;
 *   OpenViBEAcquisitionServer::uint32 m_ui32SampleCountPerSentBlock;
 *   OpenViBEAcquisitionServer::float32* m_pSample;
 * };
 * \endcode
 *
 * The configuration phase would look like this :
 *
 * \code
 * boolean CYourDriver::isConfigurable(void)
 * {
 *   return true;  // TRUE if the configure function can be called
 *                 // then the configure function will provide the information
 *                 // that the hardware is not supposed to send
 *
 *   return false; // FALSE if the configure function can not be called
 *                 // and all the information is collected from the
 *                 // hardware or from the gateway to this hardware
 * }
 *
 * boolean CYourDriver::configure(void)
 * {
 *   return false;      // FALSE if the driver is not configurable
 *
 *   ... put your       // in this case the driver needs to be configured
 *   ... configuration  // you can make a widget appear (GTK/Glade
 *   ... code here      // is recommanded for this) to get the missing
 *   return false;      // information from the user and then return
 *   return true;       // TRUE on success, FALSE on error
 * }
 * \endcode
 *
 * The initialization / uninitialization phase would look like this :
 *
 * \code
 * boolean CYourDriver::initialize(const uint32 ui32SampleCountPerSentBlock, IDriverCallback& rCallback)
 * {
 *   if(m_bInitialized) return false;
 *   if(!m_pHeader->isChannelCountSet()||!m_pHeader->isSamplingFrequencySet()) return false;
 *
 *   // Builds up a buffer to store
 *   // acquired samples. This buffer
 *   // will be sent to the acquisition
 *   // server later...
 *   m_pSample=new float32[m_pHeader->getChannelCount()*ui32SampleCountPerSentBlock];
 *   if(!m_pSample)
 *   {
 *     delete [] m_pSample;
 *     m_pSample=NULL;
 *     return false;
 *   }
 *
 *   // ...
 *   // initialize hardware and get
 *   // available header information
 *   // from it
 *   // ...
 *
 *   // Saves parameters
 *   m_pCallback=&rCallback;
 *   m_bInitialized=true;
 *   m_ui32SampleCountPerSentBlock=ui32SampleCountPerSentBlock;
 *   return true;
 * }
 *
 * boolean CYourDriver::uninitialize(void)
 * {
 *   if(!m_bInitialized) return false;
 *   if(m_bStarted) return false;
 *
 *   // ...
 *   // uninitialize hardware here
 *   // ...
 *
 *   m_bInitialized=false;
 *   delete [] m_pSample;
 *   m_pSample=NULL;
 *   m_pCallback=NULL;
 *
 *   return true;
 * }
 * \endcode
 *
 * Finally, acquisition phase looks like this :
 *
 * \code
 * boolean CYourDriver::start(void)
 * {
 *   if(!m_bInitialized) return false;
 *   if(m_bStarted) return false;
 *
 *   // ...
 *   // request hardware to start
 *   // sending data
 *   // ...
 *
 *   m_bStarted=true;
 *   return m_bStarted;
 * }
 *
 * boolean CYourDriver::loop(void)
 * {
 *   if(!m_bInitialized) return false;
 *   if(!m_bStarted) return false;
 *
 *   // ...
 *   // receive samples from hardware
 *   // store them appropriately in the sample array
 *   // when the buffer is full, send it to the acquisition server
 *   //...
 *   m_pCallback->setSamples(m_pSample);
 *
 *   return true;
 * }
 *
 * boolean CYourDriver::stop(void)
 * {
 *   if(!m_bInitialized) return false;
 *   if(!m_bStarted) return false;
 *
 *   // ...
 *   // request the hardware to stop
 *   // sending data
 *   // ...
 *
 *   m_bStarted=false;
 *   return !m_bStarted;
 * }
 * \endcode
 *
 * For a simple working example of a driver, please take a look at the generic
 * oscillator. This driver does not connect to any hardware. Instead, it
 * produces samples itself using a sinusoidal signal. This can easily
 * be tuned to match one's needs for any specific driver and also could be
 * used to test the §OpenViBE§ platform.
 *
 * \section Doc_CreatingANewDriver_Support Support
 *
 * When running into a problem while developing a driver, feel free to contact
 * experienced §OpenViBE§ developers on the mailing lists, forums or
 * IRC channels. You should also visit the §OpenViBE§ homepage to get up to date places
 * where to ask for help...
 *
 * Have fun working with §OpenViBE§ !
 */
