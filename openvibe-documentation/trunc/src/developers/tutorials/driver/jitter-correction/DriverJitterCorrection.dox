/**
\page Doc_DriverJitterCorrection Tutorial: Jitter monitoring and correction

- \b NB: Tutorial based on <b> OpenViBE 0.6.1 </b> (20-may-2010).

\section Doc_DriverJitterCorrection_Introduction Introduction

The OpenViBE framework provides some mechanisms to improve your acquisition drivers. These services are given by the IDriverContext.
We present in this tutorial the jitter monitoring and correction service. 

You can ask the driver to compare in real-time the number of samples sent by the driver to the theorical sample count, 
based on the sampling frequency. If the difference between these values goes too high, you can ask the driver to correct the jitter automatically.

\section Doc_DriverJitterCorrection_Monitoring Shifting latency and jitter

It is relatively common that the internal clock of the acquisition device does not match precisely the acquisition computer clock frequency. 
Most of the time, a latency appears with a jitter, but stays in a reasonnable range.
For example, 10 samples missing in 1 minute of acquisition, for a 512Hz theorical sampling frequency represents roughly 20 ms shift.
However it is critical to control this latency and minimize it, otherwise it can shift to an intelorable value (e.g. 1sec) 
resulting in misprocessing in OpenViBE, which relies on precisely dated data.
The monitoring service is always enabled, and the acquisition server will print a message in the console when you stop the acquisition 
if it detects that the jitter went beyond a defined threshold. This threshold is given in the openvibe configuration file, in ms:
- AcquisitionServer_ToleranceDuration = 100
It means that the acquisition server will raise a warning if the latency rises above 100 ms, when the user stopped the acquisition.
Of course, you can redefine this configuration token in your personal configuration file, lower it to 50 ms for example.

\image html warning.png "Example of warning message"

In this example, the Neurosky driver sent 636 excedent samples in a 124 seconds window. The sampling fequency is 512Hz, 
so we reached a latency of 1.24 seconds.

\section Doc_DriverJitterCorrection_Monitoring Shifting latency and jitter

Now we know that our driver latency is shifting, we have to use correction mechanism. 
To do so, you can rely on the given functions in the driver context :
\code
virtual OpenViBE::int64 	getJitterSampleCount (void)
 	Gets jitter sample count. 
virtual OpenViBE::int64 	getJitterToleranceSampleCount (void)
 	Gets the jitter sample count tolerance. 
virtual OpenViBE::int64 	getSuggestedJitterCorrectionSampleCount (void)
 	Gets the suggested jitter correction sample count. 
virtual OpenViBE::boolean 	correctJitterSampleCount (OpenViBE::int64 i64SampleCount)
 	Corrects a drifting device.
\endcode

Please read the full documentation on the IDriverContext page.
It is strongly advised to correct the jitter by the suggested value, as shown in the Neurosky driver:

\code
boolean CDriverNeuroskyMindset::loop(void)
{
	if(!m_rDriverContext.isConnected())
		return false;

	if(m_rDriverContext.isStarted())
	{
		//... read data from device and fill the buffer

		m_pCallback->setSamples(m_pSample);

		// The jitter can be negative or positive !
		if(m_rDriverContext.getJitterSampleCount() > m_rDriverContext.getJitterToleranceSampleCount()
			|| m_rDriverContext.getJitterSampleCount() < - m_rDriverContext.getJitterToleranceSampleCount())
		{
			m_rDriverContext.getLogManager() << LogLevel_Trace << "Jitter detected: "<< m_rDriverContext.getJitterSampleCount() <<" samples.\n";
			m_rDriverContext.getLogManager() << LogLevel_Trace << "Suggested correction: "<< m_rDriverContext.getSuggestedJitterCorrectionSampleCount() <<" samples.\n";

			if(! m_rDriverContext.correctJitterSampleCount(m_rDriverContext.getSuggestedJitterCorrectionSampleCount()))
			{
				m_rDriverContext.getLogManager() << LogLevel_Error << "ERROR while correcting a jitter.\n";
			}
		}
	}
	return true;
}
\endcode

Please note that the jitter correction has to be implemented \b after call to \verbatim setSamples(m_pSample), 
as the correction is performed on the buffer to be sent.

*/