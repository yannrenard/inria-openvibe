/**
 *
 * \page Doc_Tutorial_Developer_Visualisation Tutorial : create a visualisation box
 * 
 * \section Doc_Tutorial_Developer_Visualisation_Introduction Introduction
 *
 * This tutorial is only a complimentary element to the basic BoxAlgorithm
 * tutorial. The box I am describing is used in experiments with the SSVEP
 * paradigm, it displays a flickering image. The frequency of the flickering
 * can be modulated to conform to the needs of the experience. The box uses
 * solely Gtk bindings. This box illustrates how to build a visualization box
 * with Gtk and how to control it with stimulations.
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Basic_Functionality Basic Functionality
 *
 * I will describe the code itself later, first it is important to grasp what
 * this box actually does, and when. The SSVEP paradigm is based on the
 * response generated in the occipital area of the brain when a person focuses
 * on a flickering object. The response is composed of the frequency of the
 * flickering and it's harmonics.
 *
 * The box described in this tutorial is a SSVEP stimulator. Two images (of the
 * same size) are used to display a flickering object. One of the two images is
 * displayed for a fixed duration and then exchanged with the other.
 *
 * The stimulator possesses two stimulation entries. One receives stimulations
 * that control the on/off state of the box, the other receives stimulations
 * which control the frequency at which the object flickers. These frequencies
 * are defined in the user settings of the box. Each of the frequencies is
 * represented by the number of frames during which the first image is
 * displayed, and the number of frames for the second image. The box is
 * activated at 60Hz rate, maximum flickering frequency is thus 30Hz (1 frame
 * for either of the images)
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Gtk_specificities Gtk Specificities
 *
 * Since this box uses only Gtk, speed can be an issue. In order to be able to
 * achieve real time with OpenViBE the display of stimulation must be fast
 * enough so it won't perturb the whole processing chain and still be able to
 * flicker at the desired rate. Gtk possesses two means of storing image
 * bitmaps. Pixbufs are stored on the client side (from the X point of view)
 * and pixmaps are stored on the server side. This distinction is quite
 * important as the access to pixmaps is much faster but pixbufs can be
 * manipulated more easily.
 *
 * This box reads two images into pixbufs, which are then rendered to pixmaps.
 * On of them is displayed on the screen (as a GtkImage Widget), afterwards
 * they are switched periodically. The box is activated by the clock, as there
 * is no input data. When the box is resized, a handler resizes the original
 * pixbufs (into a new on) and re-renders the pixmaps.
 *
 * \section Doc_Tutorial_Developer_Visualisation_Glade_interface Glade interface
 *
 * In order to simplify the work on your widget, I would highly recommend using
 * the Glade Interface Designer. The glade file can then be loaded and used by
 * OpenViBE. For the sake of re-usability and interface integration pack all
 * widgets which do the actual displaying into one "main" widget (usually some
 * sort of Gtk box, like a horizontal box or a table) and put all the controls
 * into another widget which will then be used as a toolbar. Due to limitation
 * of Gtk version and bindings in OpenViBE, only the Glade XML format is
 * supported.
 *
 * Note also that usage of Glade is compulsory, you can create all interface
 * elements directly in the code.
 *
 * \section Doc_Tutorial_Developer_Visualisation_Header_file Header file
 *
 * \dontinclude "ovpCBoxAlgorithmGtkSSVEPVisualisation.h"
 *
 * As each header file, we will first define some \#ifdefs as guards. Includes
 * come afterwards. First we include OpenViBE header files so we can use the
 * types and templates already defined.
 *
 * \until ovtk_all
 *
 * Since this box uses glade interface we need glade headers. Gtk headers are
 * mandatory for any visualization box.
 * 
 * \until gtk.h
 *
 * This box uses a vector for some internal work described later, so it's
 * included as well.
 *
 * \until vector
 *
 * In the header file you must add the definitions of the new Box's
 * identifiers. These can be generated by the OpenViBE-id-generator-dynamic
 * program which can be found in the /dist/bin directory in the OpenViBE
 * directory structure. Note that he identifiers are generated at random,
 * however the definition space is vast enough so the probability of a clash
 * with previous identifier is nil.
 *
 * \until OVP_ClassId_BoxAlgorithm_GtkSSVEPVisualisationDesc
 *
 * Finally some defines used by the box itself.
 * SSVEPVisualisation_NumberOfFrequencies represents the number of different
 * frequencies used by the box. Each of them is identified by a number and is
 * selected upon receiving a particular stimulus.
 * SSVEPVisualisation_FrequencyLabelBase is a constant used later to transform
 * the stimulus into a frequency identifier.
 *
 * \until SSVEPVisualization_NumberOfFrequencies
 * 
 * Each OpenViBE plugin is confined in the OpenViBEPlugins namespace. Since
 * this box is a simple Gtk visualisation, it is also in the
 * SimpleVisualisation namespace.
 *
 * \until { 
 * \until {
 *
 * Each box consists of two classes : the box itself and it's descriptor. 
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_The_box_class The box class
 *
 * We'll define the box first and make it inherit from the TBoxAlgorithm
 * template and use the IBoxAlgorithm interface in order to get the basic
 * parameters and methods defined automatically.
 *
 * \until {
 *
 * At first we define public parameters and methods.
 *
 * \until public
 *
 * This structure is used as a parameter in callbacks. Since callbacks used by
 * the Gtk are plain glib callbacks, they don't have access to the object
 * members.
 *
 * \until SSVEPImageData
 *
 * Several methods must be instantiated in order for the box to run.
 *
 * The release() method cleans up the box object. Since the memory cleanup is
 * done in the uninitialize() step, we can safely delete the object.
 *
 * \until release
 *
 * The SSVEP stimulator uses clock activation rather than activation upon data
 * arrival. The getClockFrequency() method returns the frequency at which the
 * processClock() method of the object should be called.
 *
 * \until getClockFrequency
 *
 * This method will get called at desired frequency (as defined by
 * getClockFrequency())
 *
 * \until processClock
 *
 * Now for the box-specific private parameters.
 *
 * \until private
 *
 * Structure describing a flickering frequency. It holds two members : number
 * of frames during which the two images are displayed.
 *
 * \until SSVEPStimulationFrequency
 *
 * Vector containing a list of the stimulation frequencies as defined by the
 * user in the box settings.
 *
 * \until m_oFrequencySettings
 *
 * The box uses two stimulation inputs. Each of the input must have it's own
 * decoder, a memory buffer into which the stimulations are stocked before
 * treatment and a StimulationSet which is a set of stimulations ready for
 * reading.
 *
 * \until op_pFrequencyStimulationSet
 *
 * A visualization box must possess at least one parent widget, which will be
 * displayed by OpenViBE. Since I am using Glade to build the interface, it is
 * also necessary to keep the parsed glade object. Two of them, actually, since
 * the box is using a toolbar as well.
 *
 * \until m_pToolbarWidget
 *
 * Specific Gtk objects for the SSVEP box. DisplayWidget holds the image which
 * is displayed on screen. ImageData is a structure containing pointers to
 * pixmaps and pixbufs of both images. Finally three more objects are necessary
 * for the control of the widget. The three of them are part of the toolbar.
 *
 * \until m_pDarkFramesSpinButton
 *
 * Internal variables : Running describes whether the box is active (and thus
		 * flickering) or not. ElapsedFrames is used to count frames passed
 * since the last image switch. LastTime is used only for debugging purposes.
 *
 * \until m_ui64LastTime
 *
 * LitFrames and DarkFrames hold the number of frames for the first and second
 * image to display during one period respectively. CurrentFrameCount points to
 * one of these numbers depending on the image which is currently displayed.
 *
 * \until m_ui64DarkFrames
 *
 * Phase changes every time a "half period" is reached (and image switched).
 * Note that since the display lengths of the two images aren't necessarily
 * equal, the term "half period" is highly inaccurate.
 *
 * \until }
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Description Description
 *
 * Each box has a descriptor class which contains its description. This step is
 * explained in the aforementioned box algorithm tutorial.
 *
 * \until create
 *
 * One addition is, however, tied to the fact that the Box we are creating is a
 * visualization box : we have to tell the OpenViBE kernel to create a window
 * for it and display it. To do this, a method hasFunctionality must be
 * instantiated and return the necessary constant. 
 *
 * \until }
 *
 * Next we have to describe all the inputs and parameters of the box. This part
 * is pretty much covered by the standard box algorithm tutorial so I'll just
 * quickly describe what the different parameters do. 
 *
 * \until {
 *
 * This box has two inputs. Both of them are stimulation inputs. First is used
 * to star/stop the flickering of the box, the other one changes the frequency
 * at which the box flickers.
 *
 * \until Frequency
 *
 * Two images must be specified for the box. They are used for the flickering
 * target.
 *
 * \until Image OFF
 *
 * Finally, user can define up to four frequencies which can be used in one
 * experiment.
 *
 * \until Stage 4 
 * \until Stage 4
 *
 * Since the box is experimental, we flag it as unstable.
 *
 * \until endif
 *
 * \section Doc_Tutorial_Developer_Visualisation_Source_file Source file
 *
 * \dontinclude "ovpCBoxAlgorithmGtkSSVEPVisualisation.cpp"
 *
 * Includes in the file are pretty straightforward.
 *
 * \until include
 *
 * Include Time and cstdlib in order to be able to benchmark the box and to use
 * malloc.
 *
 * \until cstdlib
 *
 * Use various namespaces to reduce clutter in the code.
 *
 * \until SimpleVisualisation
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Callbacks Callbacks
 *
 * Callbacks must be defined in the default namespace. Several are defined in
 * this box in order to have control over it via it's interface.
 *
 * \until {
 *
 * The resize_image callback is used to resize the image according to its
 * container. This is a Gtk problem unrelated to OpenViBE.
 *
 * \until } 
 * \until }
 *
 * Following callbacks are used to control the box from its toolbar. They are
 * not necessary if the box is solely controlled by stimulations.
 *
 * Two callbacks are used in order to start/stop the box. Their only effect is
 * to change the value of the Running variable.
 *
 * \until } 
 * \until }
 *
 * The last callback is used to change the value of one of the periods (for the
 * first or the second image)
 *
 * \until };
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Initialization_and_deinitialization Initialization and deinitialization
 *
 * The initialize method is used to set all the member variables and load the
 * necessary data for the box to function properly.
 *
 * \until {
 *
 * By default the box isn't running and frame counter is zeroed. Phase is set
 * to false and pointer to the current phase length is set accordingly.
 *
 * \until m_ui64ElapsedFrames
 *
 * The ImageData member structure holds pointers to pixbufs and pixmaps of the
 * used images, we need to allocate memory for it.
 *
 * \until }
 *
 * Next we have to read the user settings from the box. All the settings can be
 * accessed from the BoxAlgorithmContext and are indexed beginning with 0 in
 * order in which they were declared. First two parameters hold the paths to
 * the two images which will flicker.
 *
 * \until l_sImageOff
 *
 * Following parameters hold information about the different frequencies used
 * by the box (up to four). They are read and stored in a vector for easier
 * access later. 
 *
 * \until }
 *
 * Set the current frequency to the first in the list. This setting is
 * arbitrary, user should always decide the beginning frequency with a
 * stimulation.
 *
 * \until m_ui64DarkFrames
 *
 * In order to be able to use stimulations, several structures must be
 * initialized. Each stimulation input has a decoder attached. The decoder is
 * already implemented in OpenViBE, we only need to tell the box to use it.
 *
 * \until initialize
 *
 * Once the decoder is initialized we need to set up the data structures with
 * which it will work. A decoder reads data from a MemoryBuffer filled by the
 * kernel and writes it's output to a StimulationSet which is easily readable
 * by the box.
 *
 * \until op_pSwitchStimulationSet
 *
 * Same thing is done for the Frequency stimulations.
 *
 * \until op_pFrequencyStimulationSet
 *
 * Since the box uses a Gtk interface created in Glade designer, we must read
 * the .glade file. Currently OpenViBE supports only the Glade XML bindings.
 *
 * \until m_pToolbarWidgetInterface
 *
 * Autoconnect the signals defined in the designer (note that this box uses
 * none, as Glade can only use another widgets as data for the
 * callbacks).
 *
 * \until m_pToolbarWidgetInterface
 *
 * OpenViBE needs to know which widget use for the display, any widget can be
 * used. Another widget can be also defined as a toolbar. All the box controls
 * should be contained in this toolbar.
 *
 * \until m_pToolbarWidget
 *
 * Set the default values for the spin buttons in the toolbar. (This shouldn't
 * be necessary, but there is currently a bug in the Glade designer so
 * we can't do this in there).
 *
 * \until m_ui64DarkFrames
 *
 * Loading of the images. As mentioned before, images are first loaded into
 * pixbufs, then resized to their initial size (into a temporary pixbuf) and
 * rendered onto pixmaps.
 *
 * \until pPixmap_Off
 *
 * Initialize the display widget. Only one image is displayed at a time as a
 * GtkImage widget. This widget is created in this method rather than in the
 * glade designer for easier access.
 *
 * \until gtk_widget_show
 *
 * Finally we need to connect signals emitted by the control elements in the
 * toolbar to necessary callbacks.
 *
 * \until m_pDarkFramesSpinButton
 *
 * And connect the expose_event event to the resize_image callback.
 *
 * \until }
 *
 * To uninitialize the box we need to free the objects used to hold the
 * interface, free the memory of the members held in the heap and release all
 * the OpenViBE objects. Glade XML objects are deleted and stimulation decoding
 * algorithms are released.
 *
 * \until }
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Activation Activation
 *
 * There are two ways possible to activate a box. Either it wakes up on data
 * input or it is activated by the clock at a frequency of choice. Even though
 * this box doesn't need to be activated on data input, the processInput()
 * method is mandatory. Since we don't really need it, we just tell the
 * algorithm to process any input available. The benefit of doing this is that
 * stimulations will be processed immediately upon arrival.
 *
 * \until }
 *
 * In order to wake up a box at a fixed frequency, the getClockFrequency method
 * must be implemented. Its return value is read by OpenViBE kernel and it
 * specifies the frequency at which the processClock() method of the box will
 * be called. The frequency is represented in the 32:32 fixed point arithmetic
 * format similar to the OpenViBE time. 
 *
 * \until }
 *
 * Nothing to do in processClock() either, except telling the box to process.
 *
 * \until }
 *
 * \subsection Doc_Tutorial_Developer_Visualisation_Processing Processing
 *
 * The process() method is the place where all the real work happens.
 *
 * \until {
 *
 * DynamicBoxContext object holds the current state of the box object. Among
 * other things it gives us access to its inputs.
 *
 * \until uint32
 *
 * At first we have to handle the stimulations, if there are any. The
 * getInputChunkCount(input_id) method returns the number of unprocessed
 * chunks. Each stimulation is processed individually. Switch on/off
 * stimulations are processed first.
 *
 * \until {
 *
 * Get the chunk to the MemoryBuffer and decode it.
 *
 * \until l_pStimulationSet
 *
 * A chunk can consist of several stimulations. They are processed one by one
 * as well.
 *
 * \until {
 *
 * A stimulation possesses three parameters : the time of origin, a label and a
 * duration. In this box we don't need to use the time of origin, as the
 * stimulations are processed immediately. Duration is also useless in this
 * case. We do, however, use two labels, one to tell the box to start
 * flickering and one to stop it.
 *
 * \until {
 *
 * Start flickering upon receiving the OVTK_StimulationId_VisualStimulatorStart
 * stimulation.
 *
 * \until break
 *
 * Stop flickering (and switch to the second image) upon receiving the
 * OVTK_StimulationId_VisualStimulationStop stimulation.
 *
 * \until }
 * \until }
 * \until }
 *
 * All processed chunks must be marked as deprecated. They will be deleted by
 * the kernel automatically.
 *
 * \until }
 *
 * Processing of the frequency stimulations is very similar.
 *
 * \until getStimulationCount
 * \until {
 *
 * However, instead of using just two states, we translate the stimulation
 * label into a frequency identifier (zero based index), and then change the
 * current frequency to the frequency with this index.
 *
 * \until markInputAsDeprecated
 * \until }
 *
 * Finally we have to switch the two images if necessary. This only happens if
 * the box is activated (turned ON).
 *
 * \until {
 *
 * We count the frames elapsed since the last image swap.
 *
 * \until m_ui64ElapsedFrames
 *
 * If the number of frames displayed exceeds the number of frames specified in
 * the period, we switch the images. Note that this methods relies on the
 * OpenViBE kernel to handle the eventual time offsets as the box doesn't count
 * the time itself.
 *
 * \until m_ui64ElapsedFrames = 0
 *
 * Make the frame counter pointer point to the right variable.
 *
 * \until {
 *
 * To switch the image rapidly, the box simply changes the source pixmap of the
 * displayed image widget. Since Gtk doesn't necessarily repaint all the
 * widgets immediately after a modification, we force it to do so.
 * 
 * \until return
 * \until return
 * \until }
 *
 */



